#  AC-1-4 调试 HarmonyAuth Part II

## 账号报废

真的对了？又错了！

![BUG.png](https://s2.loli.net/2023/07/24/Pkzg2ZbfevIhURj.png)

看图，只要知道一个人的下线坐标，在这个位置建造一个下界传送门，就能让这个账号无法登陆。

惯例的处理方式是，在玩家登陆前，把玩家传送到一个非下界传送门的位置。

来吧。

```java
// Check if player can open chat here
private static boolean isSafe(@Nonnull Location loc) {
    return loc.getBlock().getType() != Material.NETHER_PORTAL;
}

private static final Map<UUID, Location> originalLocation = new HashMap<>();
private static final int skyHeight = 512;
private static final int maxSearchVolume = 256;
private static final Vector[] directions = {
        new Vector(1, 0, 0),
        new Vector(0, 1, 0),
        new Vector(0, 0, 1),
        new Vector(-1, 0, 0),
        new Vector(0, -1, 0),
        new Vector(0, 0, -1),
};

// Let player log in in a safe place
private static void ensureSafety(@Nonnull Player player) {
    if (isSafe(player.getLocation())) {
        return;
    }
    // If the position is unsafe, first try to search nearby
    ArrayDeque<Location> queue = new ArrayDeque<>();
    HashSet<Location> visited = new HashSet<>();
    queue.addLast(player.getLocation().toBlockLocation());
    Location solution = null;
    while (!queue.isEmpty() && visited.size() <= maxSearchVolume) {
        Location loc = queue.removeFirst();
        if (visited.contains(loc)) {
            continue;
        }
        visited.add(loc);
        if (isSafe(loc)) {
            solution = loc;
            break;
        }
        for (Vector direction : directions) {
            queue.addLast(loc.clone().add(direction));
        }
    }
    // Or else we may fall back to logging in in the sky
    if (solution == null) {
        Location loc = player.getLocation().clone();
        loc.setY(skyHeight);
        solution = loc;
    }
    originalLocation.put(player.getUniqueId(), player.getLocation().clone());
    player.teleport(solution);
}

public static void restoreLocation(@Nonnull Player player) {
    if (Bukkit.isPrimaryThread()) {
        Location loc = originalLocation.remove(player.getUniqueId());
        if (loc != null) {
            player.teleport(loc);
        }
    } else {
        Bukkit.getScheduler().runTask(HarmonyAuthSMART.instance, () -> restoreLocation(player));
    }
}

```
::: danger 这段代码问题，待会我们要调试它。
:::

然后我们在要求登录时onPlayerJoin中调用`ensureSafety`，在登录成功或者玩家退出游戏时调用`restoreLocation`。

```java
ensureSafety(e.getPlayer());
restoreLocation(e.getPlayer());
```

再次启动服务端！

然而，令人失望的是，即使我们在传送门中退出游戏，登录插件也没有把我们传送到安全的地方。

更令人失望的是，后台并没有报错告诉我们哪里出错了。

这时候，一批专业的工具就派上用场了。

### 使用「IDEA」的调试功能调试插件

首先，启动服务端时设置Java代理。

```bash
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8342 -jar paper-mojmap-1.20.1-95.jar
```
::: info <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M9.1 0C10.2 0 10.7 0.7 10.7 1.6 10.7 2.6 9.8 3.6 8.6 3.6 7.6 3.6 7 3 7 2 7 1.1 7.7 0 9.1 0Z'/%3E%3Cpath d='M5.8 16C5 16 4.4 15.5 5 13.2L5.9 9.1C6.1 8.5 6.1 8.2 5.9 8.2 5.7 8.2 4.6 8.6 3.9 9.1L3.5 8.4C5.6 6.6 7.9 5.6 8.9 5.6 9.8 5.6 9.9 6.6 9.5 8.2L8.4 12.5C8.2 13.2 8.3 13.5 8.5 13.5 8.7 13.5 9.6 13.2 10.4 12.5L10.9 13.2C8.9 15.2 6.7 16 5.8 16Z'/%3E%3C/svg%3E" style="background-color:#0B87DA; clip-path: circle();" width="24px" height="24px"> **关键参数的解释**
`suspend=n`：不等待调试器连接，直接启动服务端。若需要等待IDEA的调试器连接再启动服务端，将其改为`suspend=y`。
`port=8342`：调试器连接的端口号。没有什么讲究，只是不要与其他程序冲突即可。8342是我随便写的。
:::

::: danger <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M10 14C10 15.1 9.1 16 8 16 6.9 16 6 15.1 6 14 6 12.9 6.9 12 8 12 9.1 12 10 12.9 10 14Z'/%3E%3Cpath d='M10 1.6C10 1.2 9.8 0.9 9.6 0.7 9.2 0.3 8.6 0 8 0 7.4 0 6.8 0.2 6.5 0.6 6.2 0.9 6 1.2 6 1.6 6 1.7 6 1.8 6 1.9L6.8 9.6C6.9 9.9 7 10.1 7.2 10.2 7.4 10.4 7.7 10.5 8 10.5 8.3 10.5 8.6 10.4 8.8 10.3 9 10.1 9.1 9.9 9.2 9.6L10 1.9C10 1.8 10 1.7 10 1.6Z'/%3E%3C/svg%3E" style="background-color:#DA0B50; clip-path: circle();" width="24px" height="24px"> **不建议不加参数直接启动**
即使不加`-javaagent`参数，IDEA也可以转而利用Root权限附加到被调试进程。但是有很多不建议这样做的理由，例如：
- 没有Java Agent，支持的调试操作严重受限，大部分调试操作都无法使用。
- Root权限的授权向来都是需要严格控制的。
:::

// TODO...

## 刷物品和结构位置泄漏

我们发现：在使用Harmony Auth登录插件的服务器中，管理员账号在未登录状态可以使用`/loot`、`/locate`等命令。

聪明的你，能猜到为什么吗？

<button type='button' class="btn-unconfirmed" style="width:100%;transition:500ms;" onclick="document.getElementById('solution1').style.display = 'block';this.onclick=function(){};this.style.display = 'none'"> ❔ 揭晓谜底 </button>

<div id='solution1' style='display:none;'>

> HarmonyAuth SMART使用`String::startsWith`判断命令是否在白名单内，而为了使玩家登录白名单中有登录命令`/l`。这在真实的服务器中会允许`/luckperms`等敏感命令的使用。
</div>

## 结束了

就这么多了。

也许还有更多的漏洞。许多奇怪设计比如未登陆玩家无法受到伤害却能吸引怪物火力、在载具上登录会遭到刷屏等，受教程所限就不再修改了。

有些项目没来得及测试，例如登录时取消已经创建的请求，重新创建请求时自动覆盖。当然，笔者事后测试成功了（查数据库可知）。至于钩子能否运行……既然配置空命令也没出错，我们就权且相信它可以正常运行吧——开玩笑的，笔者测试过没有问题的啦~

至于登录时按着 `w` 移动鼠标会回弹的现象……应该不会有人这么无聊吧？如果有，那回弹也是自作自受（笑）。

密码中不能包含空格，设计如此。如果你的密码包含空格并且每一段都相同，那也不影响注册和登录。重设密码时，如果包含空格将无法通过。基本上没有大问题了。

本次行动的源代码：https://github.com/Andy-K-Sparklight/PluginDiaryCode/tree/master/HarmonyAuth%20SMART/src

## 行动总结

战斗还是很艰难的，但我们做到了！AsyncPlayerChatEvent

笔者写这两节写了两遍，并且好几次都有过放弃的念头，但最终坚持下来了。其实笔者能够在这里写出教程并非因为笔者技艺精湛或者经验丰富，只是我能够一直坚持。

这个插件已经能够使用了，笔者把它安装在了自己的服务器上，也算是一个纪念吧。

## 行动结束

<button type='button' class="btn-unconfirmed" style="width:100%;transition:500ms;" onclick="this.innerHTML=' ✓ 恭喜！';document.getElementById('hiddenEle').style.display = 'block';this.className='btn-confirmed';this.onclick=function(){};"> ❔ 确认行动结束 </button>

<div id='hiddenEle' style='display:none;'>

> 行动结果：胜利

不容易啊，笔者写到这里花了一周，各位读者大概会比我要快一点吧？（毕竟笔者需要打字）

笔者认为，到目前为止，你已经掌握了插件开发需要的全部基础知识。接下来我们将学习一些高级知识和小技巧，并且由此开始通向最终的旅程。

回顾你编写的「Hello World」，记忆犹新？很好，那一章是「基础之基础」，而我们下一章的内容，叫做「终极之开端」。

最后感谢你的坚持，也感谢笔者自己。现在的你一定成就感满满吧？那我们来一首应景的歌~

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height=86 src="//music.163.com/outchain/player?type=2&id=28077562&auto=0&height=66"></iframe>

下一章，内容更精彩！

</div>